# Bertalign 对齐行为说明

## 🔍 核心发现

经过大量测试，我们发现了Bertalign的一个重要特性：

**Bertalign会尽可能对齐所有句子，很少产生空对齐（缺失/增添）**

---

## 📊 测试证据

### 测试1: 正常比例 (9句 vs 6句)

**结果**: 所有句子都被对齐，包括4:2的复杂对齐

```
对齐组:
1. [0] → [0]  (1:1)
2. [1] → [1]  (1:1)
3. [2,3,4,5] → [2,3]  (4:2) ← 复杂对齐
4. [6,7] → [4]  (2:1)
5. [8] → [5]  (1:1)
```

### 测试2: 极端比例 (10句 vs 3句)

**结果**: 即使10:3的极端比例，仍然全部对齐

```
对齐组:
1. [0] → [0]  (1:1)
2. [1,2,3,4,5] → [1]  (5:1) ← 5句对齐到1句！
3. [6,7,8,9] → [2]  (4:1) ← 4句对齐到1句！
```

### 测试3: 完全不相关的句子 (7句 vs 8句)

**源文本**: 关于量子计算、机器学习等
**目标文本**: 包含"额外增加的安全协议"、"培训要求"等不相关内容

**结果**: 仍然全部对齐，没有产生空对齐

```
对齐组:
1. [0] → [0]  (1:1)
2. [1] → [1]  (1:1)
3. [2] → [2]  (1:1)
4. [3] → [3,4]  (1:2) ← 将不相关的T3强制对齐
5. [4,5] → [5]  (2:1)
6. [6] → [6,7]  (1:2) ← 将不相关的T7强制对齐
```

---

## 🎯 Bertalign的设计哲学

Bertalign使用**动态规划算法**，目标是找到**全局最优对齐方案**，而不是产生空对齐。

### 算法逻辑

1. **第一步**: 使用LaBSE计算所有句子的embedding
2. **第二步**: 使用动态规划找到最优对齐路径
3. **评分函数**: `对齐得分 = 相似度 + skip惩罚`

### skip参数的作用

- `skip=-0.1` (默认): 轻微惩罚跳过
- `skip=-1.0` (我们的设置): 强惩罚跳过，倾向于N:M对齐

**关键点**: 即使`skip=-1.0`，如果对齐得分仍然高于跳过惩罚，算法仍会选择对齐。

---

## 💡 对翻译质量检查的影响

### 1. 缺失 (Omission) 检测

**理论**: 原文句子在译文中没有对应 → 空对齐 `([i], [])`

**实际**: Bertalign会将缺失的句子对齐到最相似的目标句子（即使相似度很低）

**示例**:
```
S2: "Operating at temperatures near absolute zero is essential."
应该缺失，但被对齐到:
T2: "系统架构在2024年第四季度重新设计。"
形成 [2,3,4,5] → [2,3] 的4:2对齐
```

### 2. 增添 (Addition) 检测

**理论**: 译文句子在原文中没有对应 → 空对齐 `([], [j])`

**实际**: Bertalign会将增添的句子对齐到最相似的源句子

**示例**:
```
T3: "译文中额外增加了关于安全协议的内容，这在原文中完全没有提及。"
应该是增添，但被对齐到:
S3: "The previous version lacked modularity."
形成 [3] → [3,4] 的1:2对齐
```

### 3. 相似度低 (Low Similarity) 检测

**实际效果**: ✅ **有效**

当Bertalign强制对齐不相关的句子时，相似度会很低（< 0.7），可以被检测为"相似度低"。

**示例**:
```
S8: "(This final sentence is entirely redundant...)"
T5: "这份译文额外多了一句话。"
对齐相似度: 0.5200 ← 被标记为"相似度低"
```

---

## 📋 CSV报告中的"增添"

CSV报告中看到的空行（如T4、T7）**不是真正的增添**，而是**N:M对齐的多行平铺**。

### 示例

**对齐**: `[3] → [3,4]` (1:2对齐)

**CSV展开**:
```csv
原文,译文,源索引,目标索引,相似度,异常
S3,T3,3,3,0.78,OK     ← 第1行：显示源和目标
,T4,,4,,              ← 第2行：只显示额外的目标
```

这里的T4**不是增添**，而是与S3一起对齐的第二个目标句子。

---

## ✅ 结论

### 1. 空对齐处理逻辑是正确的

我们实现的空对齐检测逻辑（`similarity=None`, `is_null_alignment=True`）是**正确的**，只是Bertalign很少产生空对齐。

### 2. 实际的异常检测

在实际使用中，翻译异常主要通过以下方式检测：

| 异常类型 | 检测方式 | 效果 |
|---------|---------|------|
| 缺失 (Omission) | 空对齐 `([i], [])` | ❌ 很少发生 |
| 缺失 (Omission) | N:M对齐 + 相似度低 | ✅ 间接检测 |
| 增添 (Addition) | 空对齐 `([], [j])` | ❌ 很少发生 |
| 增添 (Addition) | N:M对齐 + 相似度低 | ✅ 间接检测 |
| 相似度低 | 相似度 < 0.7 | ✅ 直接检测 |

### 3. 用户使用建议

**查看CSV报告时**:
- ✅ 关注"相似度低"的对齐组
- ✅ 关注N:M对齐（如4:2, 1:2, 2:1），检查是否有不相关的句子被强制对齐
- ✅ 手动审查多行平铺的对齐组，判断是否有实际的缺失/增添

**调整参数**:
- 降低`similarity_threshold`（如0.6）可以减少误报
- 增大`skip`惩罚（如-2.0）可能增加空对齐的概率（但效果有限）

---

## 🔬 未来改进方向

如果需要更准确的缺失/增添检测，可以考虑：

1. **后处理分析**: 对N:M对齐进行二次分析，检测是否有明显不相关的句子
2. **相似度阈值**: 对N:M对齐设置更严格的相似度要求
3. **自定义对齐算法**: 修改Bertalign的评分函数，增加空对齐的倾向

但对于大多数实际应用，**当前的相似度低检测已经足够有效**。

